---
layout: post
title: 운영체제란? 
date: 2025-06-08
description: 운영체제가 무엇인지 간단하게 알아보자
tags:
  - Operating System
author: Choi Jang Woo
toc: true
categories: [개발 서적, Operating System] 
---
### 운영체제의 세 가지 주요 목적은 무엇인가?
> 세 가지 주요 목적은 다음과 같습니다. 
1. 하드웨어 위에서 프로그램을 사용자가편리하고 효율적인 방식으로 실행할 수 있는 환경을 제공합니다.
2. 필요한 작업을 수행하기 위해 컴퓨터의 개별 자원을 할당합니다. 할당할 때는 최대한 공정하고 효율적이어야 합니다.
3. 제어 프로그램으로서 두 가지 주요 기능을 수행합니다.
    - 사용자 프로그램의 실행을 관리하여 에러나 부적절한 컴퓨터 사용을 방지합니다.
    - 입출력 장치의 동작 및 제어를 관리합니다.

### 커널 모드와 사용자 모드의 구별은 기본적인 형태의 보호로서 어떤 기능을 하는가?
> 커널 모드에서만 실행 가능한 특정 명령 (I/O 장치 접근, 인터럽트 제어, 메모리 보호 레지스터 설정 등)이 사용자 모드에서는 실행되지 못하도록 강제합니다. 그 결과 사용자 모드에서는 핵심 자원에 대한 접근이 제한되어 시스템 전체의 안정성과 보안이 확보될 수 있습니다.

### 다음 중 특권 명령이어야 하는 명령어는 무엇인가?
> a. 타이머 값 설정
b. 시계 읽기
c. 메모리 초기화
d. 트랩(trap) 명령 실행
e. 인터럽트 끄기
f. 장치 상태 테이블 수정
g. 사용자 모드에서 커널 모드로 전환
h. I/O 장치 접근

> 특권 명령이란 CPU가 커널 모드에서만 실행을 허용하고 사용자 모드에서는 실행을 금지하는 명령어를 말합니다. 이 이유는 이들 명령이 하드웨어 자원이나 시스템 전체의 안정성 및 보안에 직접적으로  관여할 수 있기 때문입니다. 따라서 특권 명령이어야하는 명령어는 다음과 같습니다. 

>a. 타이머 값 설정
c. 메모리 초기화
e. 인터럽트 끄기
f. 장치 상태 테이블 수정
h. I/O 장치 접근

### 일부 CPU는 세 개 이상의 작동 모드를 제공한다. 이 다중 모드를 사욯할 수 있는 두 가지 경우는 무엇인가? 
1. 세분화된 보안 정책 구현
    - 예를 들어, 동일 그룹 사용자끼리만 서로의 코드를 실행할 수 있는 그룹별 사용자 모드를 두어 해당 그룹 모드에서만 실행 권한을 부여할 수 있습니다.

2. 커널 내부 기능 분리
    - USB 장치 드라이버 전용 모드를 두어 USB 장치를 서비스할 때만 해당 모드로 전환하고 나머지 시간에는 일반 커널 모드로 실행하게 할 수 있고 이때 USB 드라이버를 준(準)커널 모드에서 실행할 수 있게됩니다.

### 타이머는 현재 시간을 계산하는데 사용될 수 있다. 어떻게 계산이 가능한지 간단하게 설명하라.

1. 하드웨어 타이머를 특정 주기(1초 또는 1밀리초)마다 인터럽트를 발생하도록 설정합니다.
2. 인터럽트 발생 시마다 카운터를 1씩 증가시킵니다.
3. 부팅 시점의 실시간 시계(RTC) 값을 기준으로 누적된 틱(tick) 수에 틱 주기를 곱해 더하면 현재 시간을 계산할 수 있습니다.

### 캐시의 의의
#### 본 질문. 캐시가 유용한 두 가지 이유를 제시하라. 어떤 문제를 해결할 수 있는가? 어떤 문제를 야기하는가? 캐시의 크기를 캐싱하는 장치만큼 크게 만들 수 있다면 캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 무엇인가?

1. 캐시가 유용한 이유
속도 차이가 큰 두 장치, CPU와 메인 메모리 사이의 데이터 전송 속도 차이를 완화하여 전체 성능을 향상시킵니다. 또한 자주 참조되는 데이터를 캐시에 유지해 메모리 대역폭 사용량을 절감할 수 있습니다. 캐시의 이러한 기능을 통해 기능의 latency가 줄어들고 버스의 혼잡 문제를 완화시킬 수 있습니다.

2. 하지만 멀티코어 시스템에서 캐시 일관성(coherency) 유지가 어려워지며 실시간 시스템에서 캐시 미스로 인해 예측 불가능한 지연이 발생할 수 있는 문제가 있습니다. 

3. 캐시를 본체와 같은 크기로 만들지 않는 이유는 
    1. 캐시는 SRAM 기반으로 제작되어 DRAM(또는 디스크)보다 비용이 훨씬 높고 전력 소모가 큽니다.
    2. 크기가 커지면 태그 매칭 등 관리 오버헤드가 증가해 오히려 성능이 저하됩니다.
    3. 일정 규모 이상에서는 캐시 미스율 감소 효과가 미미해져 투자 대비 효용이 낮아질 수 있습니다.

> 캐시에서 태그 매칭(tag matching)은 다음 과정을 말합니다.

1. 주소 분할

   * CPU가 요청하는 메모리 주소는 크게 세 부분으로 나뉩니다.

     1. 태그(tag): 블록이 어디에 위치하는지를 식별하는 최상위 비트들
     2. 인덱스(index): 캐시 내에서 어느 세트(set)나 라인(line)을 참조할지를 결정하는 비트들
     3. 블록 오프셋(offset): 해당 캐시 라인 내부에서의 바이트 위치

2. 인덱스 기반 라인 선택

   * 요청 주소의 인덱스 부분을 보고, 캐시에서 해당 인덱스(세트)에 저장된 라인들(way)을 찾아냅니다.

3. 태그 비교

   * 그 세트에 있는 각 캐시 라인의 태그 필드(실제 메모리 주소의 태그 비트)를
     요청 주소의 태그 비트와 비교(매칭)합니다.
   * 태그가 일치하면 “캐시 히트(hit)”이고,
   * 일치하는 라인이 없으면 “캐시 미스(miss)”가 됩니다.


### 태그 매칭의 오버헤드가 커지는 이유

* 캐시가 커져서 **세트 당 way 수**(associativity)나 **전체 라인 수**가 많아지면, 하나의 세트에 있는 라인 전체의 태그를 매번 비교해야 하기 때문에
* **비교 연산(compare)** 자체가 더 많아지고, 비교 결과를 결정하는 로직(멀티플렉서 등)도 복잡해져 결국 전기적 신호 지연(latency)과 **회로 복잡도**가 증가하여 캐시 접근 속도가 느려질 수 있습니다.

요약하자면 캐시는 요청 주소의 태그와 캐시 라인의 태그를 비교해서 히트 여부를 판단하는데
캐시가 커질수록 이 태그 매칭 작업이 많아져 오히려 성능에 악영향을 줄 수 있습니다.


### 출처 
[Operating System Concepts
Tenth Edition](https://codex.cs.yale.edu/avi/os-book/OS10/practice-exercises/index-solu.html)
