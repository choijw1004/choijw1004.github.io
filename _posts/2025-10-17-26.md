---
layout: post
title:  "Effective Java - item 20"
description: 추상 클래스보다는 인터페이스를 우선하라 
date: 2025-10-17
tags:
  - Effective Java
author: Choi Jang Woo
toc: true
categories: [개발 서적, Effective Java] 
---

## 들어가며
자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다. 자바 8부터 인터페이스도 디폴트 메서드(default method)를 제공할 수 있게 되어, 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.

둘의 가장 큰 차이는, 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다. 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

## 인터페이스의 장점 
### 1. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다

인터페이스가 요구하는 메서드를 (아직 없다면) 추가하고, 클래스 선언에 `implements` 구문만 추가하면 끝이다.

```java
// 기존 클래스
public class MyClass {
    // 기존 코드
}

// 나중에 Comparable 인터페이스 추가
public class MyClass implements Comparable<MyClass> {
    // 기존 코드
    
    @Override
    public int compareTo(MyClass o) {
        // 비교 로직 추가
        return Integer.compare(this.value, o.value);
    }
}
```

자바 플랫폼에서도 `Comparable`, `Iterable`, `AutoCloseable` 인터페이스가 새로 추가됐을 때 표준 라이브러리의 수많은 기존 클래스가 이 인터페이스들을 구현한 채 릴리스됐다.

반면, 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 어려운 게 일반적이다. 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다. 안타깝게도 이 방식은 클래스 계층구조에 커다란 혼란을 일으킨다.

```java
// 추상 클래스 방식의 문제
abstract class Musician {
    abstract void play();
}

abstract class Writer {
    abstract void write();
}

// 자바는 단일 상속만 지원하므로 불가능
class SingerSongwriter extends Musician, Writer { 
    // ...
}
```

### 2. 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다

믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.

예를 들어 `Comparable`은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스다.

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    // 추가 기능(믹스인): 비교 가능
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}
```

이처럼 대상 타입의 주된 기능에 선택적 기능을 섞는다(mixed in)고 해서 믹스인이라 부른다. 추상 클래스로는 믹스인을 정의할 수 없다. 이유는 앞서와 같이, 기존 클래스에 덧씌울 수 없기 때문이다. 클래스는 두 부모를 섬길 수 없고, 클래스 계층구조에는 믹스인을 삽입하기에 합리적인 위치가 없다.

### 3. 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다

타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.

```java
// 가수 인터페이스
public interface Singer {
    AudioClip sing(Song s);
}

// 작곡가 인터페이스
public interface Songwriter {
    Song compose(int chartPosition);
}
```

우리 주변엔 작곡도 하는 가수가 제법 있다. 이 코드처럼 타입을 인터페이스로 정의하면 가수 클래스가 `Singer`와 `Songwriter` 모두를 구현해도 전혀 문제되지 않는다.

```java
// 가수이자 작곡가
public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip strum();
    void actSensitive();
}
```

심지어 `Singer`와 `Songwriter` 모두를 확장하고 새로운 메서드까지 추가한 제3의 인터페이스를 정의할 수도 있다.

같은 구조를 클래스로 만들려면 가능한 조합 전부를 각각의 클래스로 정의한 고도비만 계층구조가 만들어질 것이다. 속성이 n개라면 지원해야 할 조합의 수는 2^n개나 된다. 이를 조합 폭발(combinatorial explosion)이라 부른다.

```java
// 추상 클래스로 시도하면...
abstract class Singer {
    abstract AudioClip sing(Song s);
}

abstract class Songwriter {
    abstract Song compose(int chartPosition);
}

// 둘 다 필요하면? 새로운 클래스를 만들어야 함
abstract class SingerSongwriter {
    abstract AudioClip sing(Song s);
    abstract Song compose(int chartPosition);
    abstract void strum();
    abstract void actSensitive();
}
```


## 디폴트 메서드의 등장

자바 8부터 인터페이스에 디폴트 메서드(default method)를 제공할 수 있게 되었다. 디폴트 메서드를 사용하면 인터페이스에도 구현을 제공할 수 있다.

```java
public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
    boolean remove(Object o);
    Iterator<E> iterator();
    int size();
    
    // 디폴트 메서드
    default boolean isEmpty() {
        return size() == 0;
    }
    
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            if (filter.test(it.next())) {
                it.remove();
                removed = true;
            }
        }
        return removed;
    }
}
```

### 디폴트 메서드의 제약

디폴트 메서드에도 제약은 있다. 많은 인터페이스가 `equals`와 `hashCode` 같은 Object의 메서드를 정의하고 있지만, 이들은 디폴트 메서드로 제공해서는 안 된다.

```java
public interface MyInterface {
    // 컴파일 에러 
    // Object 메서드는 디폴트 메서드로 제공 불가
    default boolean equals(Object obj) {
        return false;
    }
}
```

또한 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다(단, private 정적 메서드는 예외다).

## 인터페이스와 추상 골격 구현 클래스

인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다. 인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. 그리고 골격 구현(skeletal implementation) 클래스는 나머지 메서드들까지 구현한다. 이렇게 해두면 단순히 골격 구현을 확장하는 것만으로 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. 바로 **템플릿 메서드 패턴**이다.

관례상 인터페이스 이름이 Interface라면 그 골격 구현 클래스의 이름은 AbstractInterface로 짓는다. 좋은 예로, 컬렉션 프레임워크의 `AbstractCollection`, `AbstractSet`, `AbstractList`, `AbstractMap` 각각이 바로 핵심 컬렉션 인터페이스의 골격 구현이다.

### 골격 구현 작성 예시

```java
// 1단계: 인터페이스 정의
public interface List<E> extends Collection<E> {
    boolean add(E e);
    E get(int index);
    int size();
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);
    int indexOf(Object o);
    // ... 기타 메서드들
}

// 2단계: 골격 구현 클래스
public abstract class AbstractList<E> implements List<E> {
    
    // 하위 클래스가 반드시 구현해야 할 메서드
    abstract public E get(int index);
    abstract public int size();
    
    // 공통 구현 제공
    public boolean isEmpty() {
        return size() == 0;
    }
    
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }
    
    public int indexOf(Object o) {
        ListIterator<E> it = listIterator();
        if (o == null) {
            while (it.hasNext()) {
                if (it.next() == null)
                    return it.previousIndex();
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next()))
                    return it.previousIndex();
            }
        }
        return -1;
    }
    
    public E set(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }
}

// 3단계: 실제 구현 클래스
public class ArrayList<E> extends AbstractList<E> {
    private Object[] elementData;
    private int size;
    
    public E get(int index) {
        return (E) elementData[index];
    }
    
    public int size() {
        return size;
    }
    
    // set, add, remove 재정의하여 실제 구현
    public E set(int index, E element) {
        E oldValue = get(index);
        elementData[index] = element;
        return oldValue;
    }
}
```

### 골격 구현의 장점

- 골격 구현 클래스의 장점은 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 제약에서는 자유롭다는 점이다.

- 구조상 골격 구현을 확장하지 못하는 상황이라면 인터페이스를 직접 구현해야 한다. 이런 경우라도 인터페이스가 직접 제공하는 디폴트 메서드의 이점을 가진다.

- 또한, 골격 구현 클래스를 우회적으로 이용할 수도 있다. 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다. 이를 다중 상속(simulated multiple inheritance)이라 하며, 다중 상속의 많은 장점을 제공하는 동시에 단점은 피하게 해준다.


### 골격 구현 작성 방법

골격 구현 작성은 상대적으로 쉽다.

1. 먼저 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정한다. 이 기반 메서드들은 골격 구현에서는 추상 메서드가 될 것이다.

2. 그 다음으로 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다. 단, equals와 hashCode 같은 Object의 메서드는 디폴트 메서드로 제공하면 안 된다.

3. 만약 인터페이스의 메서드 모두가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들 이유는 없다.

4. 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다. 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가해도 된다.

### 간단한 예: Map.Entry 인터페이스

```java
// Map.Entry 인터페이스
public interface Entry<K, V> {
    K getKey();
    V getValue();
    V setValue(V value);
    boolean equals(Object o);
    int hashCode();
}

// 골격 구현 클래스
public abstract class AbstractMapEntry<K, V> implements Map.Entry<K, V> {
    
    // 하위 클래스가 반드시 구현해야 할 메서드
    @Override
    public abstract K getKey();
    
    @Override
    public abstract V getValue();
    
    // 변경 가능한 엔트리는 이 메서드를 재정의해야 한다
    @Override
    public V setValue(V value) {
        throw new UnsupportedOperationException();
    }
    
    // Map.Entry.equals의 일반 규약을 구현한다
    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?, ?> e = (Map.Entry) o;
        return Objects.equals(e.getKey(), getKey())
                && Objects.equals(e.getValue(), getValue());
    }
    
    // Map.Entry.hashCode의 일반 규약을 구현한다
    @Override
    public int hashCode() {
        return Objects.hashCode(getKey())
                ^ Objects.hashCode(getValue());
    }
    
    @Override
    public String toString() {
        return getKey() + "=" + getValue();
    }
}
```

`Map.Entry` 인터페이스나 그 하위 인터페이스로는 이 골격 구현을 제공할 수 없다. 디폴트 메서드는 equals, hashCode, toString 같은 Object 메서드를 재정의할 수 없기 때문이다.

골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 아이템 19에서 이야기한 설계 및 문서화 지침을 모두 따라야 한다. 

```java
// 간단한 Entry 구현
public class SimpleEntry<K, V> extends AbstractMapEntry<K, V> {
    private final K key;
    private final V value;
    
    public SimpleEntry(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    @Override
    public K getKey() {
        return key;
    }
    
    @Override
    public V getValue() {
        return value;
    }
    
    // equals, hashCode, toString은 AbstractMapEntry가 구현해준다.
}
```

### 단순 구현(simple implementation)

골격 구현의 작은 변종으로, `AbstractMap.SimpleEntry`가 좋은 예다. 단순 구현도 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니란 점이 다르다. 쉽게 말해 동작하는 가장 단순한 구현이다. 이러한 단순 구현은 그대로 써도 되고 필요에 맞게 확장해도 된다.

## 결론

> 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 복잡한 인터페이스라면 골격 구현을 함께 제공하는 방법을 꼭 고려해보자. 골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다. 